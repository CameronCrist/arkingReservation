// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { FHE, euint8, euint16, euint32, euint64, ebool, einput, Gateway } from "@fhevm/solidity/lib/FHE.sol";
import { SepoliaConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title PrivateParkingReservation - FHE-powered privacy-preserving parking reservation system
/// @notice This contract demonstrates advanced FHE features including Gateway integration,
///         multiple encryption types, fail-closed design, and complex encrypted logic
/// @dev Implements Zama's FHEVM with Gateway for decryption callbacks
contract PrivateParkingReservation is SepoliaConfig {

    address public owner;
    address public pauser;
    bool public paused;

    uint32 public totalSpots;
    uint32 public reservationCounter;

    // Gateway request tracking
    mapping(uint256 => GatewayRequest) private gatewayRequests;
    uint256 private gatewayRequestCounter;

    /// @notice Tracks Gateway decryption requests
    struct GatewayRequest {
        address requester;
        uint32 spotId;
        RequestType requestType;
        bool fulfilled;
    }

    enum RequestType {
        AVAILABILITY_CHECK,
        PRICE_REVEAL,
        RESERVATION_APPROVAL
    }

    struct ParkingSpot {
        euint32 encryptedPrice;        // 加密的停车位价格 (使用euint32支持更大价格范围)
        euint8 encryptedStatus;        // 加密状态: 0=可用, 1=已预订, 2=维护中
        bool isActive;                 // 停车位是否激活
        euint32 encryptedReservedBy;   // 加密的预订者ID
        euint64 encryptedReservationEnd; // 加密的预订结束时间戳
        string location;               // 停车位位置信息
        euint32 encryptedCapacity;     // 加密容量（车辆大小限制）
    }

    struct UserProfile {
        euint32 encryptedUserId;       // 加密用户ID
        euint32 encryptedCreditScore;  // 加密信用评分 (使用euint32支持0-1000范围)
        ebool hasValidLicense;         // 加密驾照验证状态
        euint64 encryptedWalletBalance; // 加密钱包余额
        bool isRegistered;             // 是否已注册
        uint256 totalReservations;     // 总预订次数
        uint256 lastReservation;       // 最后预订时间
    }

    struct Reservation {
        uint32 spotId;                 // 停车位ID
        euint32 encryptedUserId;       // 加密用户ID
        euint32 encryptedPaidAmount;   // 加密支付金额
        euint64 encryptedStartTime;    // 加密开始时间
        euint64 encryptedEndTime;      // 加密结束时间
        euint8 encryptedStatus;        // 加密状态: 0=进行中, 1=已完成, 2=已取消
        ebool isApproved;              // 加密审批状态
        bool isActive;                 // 是否激活
    }

    mapping(uint32 => ParkingSpot) public parkingSpots;
    mapping(address => UserProfile) public userProfiles;
    mapping(uint256 => Reservation) public reservations;
    mapping(address => uint256[]) public userReservations;

    // 加密映射：用户地址到加密用户ID
    mapping(address => euint32) private encryptedUserIds;

    // Events with comprehensive logging for transparency
    event SpotAdded(uint32 indexed spotId, string location, uint256 timestamp);
    event UserRegistered(address indexed user, uint256 timestamp);
    event ReservationCreated(uint256 indexed reservationId, uint32 indexed spotId, address indexed user, uint256 timestamp);
    event ReservationApproved(uint256 indexed reservationId, uint32 indexed spotId, uint256 timestamp);
    event ReservationCompleted(uint256 indexed reservationId, uint32 indexed spotId, uint256 timestamp);
    event ReservationCancelled(uint256 indexed reservationId, uint32 indexed spotId, uint256 timestamp);
    event SpotStatusUpdated(uint32 indexed spotId, uint256 timestamp);
    event PriceUpdated(uint32 indexed spotId, uint256 timestamp);
    event GatewayRequestInitiated(uint256 indexed requestId, address indexed requester, RequestType requestType);
    event GatewayRequestFulfilled(uint256 indexed requestId, bool success);
    event ContractPaused(address indexed pauser, uint256 timestamp);
    event ContractUnpaused(address indexed pauser, uint256 timestamp);
    event PauserChanged(address indexed oldPauser, address indexed newPauser);
    event BalanceUpdated(address indexed user, uint256 timestamp);

    // Custom errors for fail-closed design
    error NotAuthorized();
    error UserNotRegistered();
    error InvalidSpotId();
    error SpotNotActive();
    error ContractPaused();
    error InvalidCreditScore();
    error InsufficientBalance();
    error InvalidDuration();
    error SpotNotAvailable();
    error ReservationNotActive();
    error InvalidReservationId();
    error TooLateToCancel();
    error GatewayRequestNotFulfilled();

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotAuthorized();
        _;
    }

    modifier onlyPauser() {
        if (msg.sender != pauser && msg.sender != owner) revert NotAuthorized();
        _;
    }

    modifier whenNotPaused() {
        if (paused) revert ContractPaused();
        _;
    }

    modifier onlyRegistered() {
        if (!userProfiles[msg.sender].isRegistered) revert UserNotRegistered();
        _;
    }

    modifier validSpot(uint32 spotId) {
        if (spotId >= totalSpots) revert InvalidSpotId();
        if (!parkingSpots[spotId].isActive) revert SpotNotActive();
        _;
    }

    constructor() {
        owner = msg.sender;
        pauser = msg.sender;
        paused = false;
        totalSpots = 0;
        reservationCounter = 0;
        gatewayRequestCounter = 0;
    }

    /// @notice Emergency pause function - fail-closed design
    function pause() external onlyPauser {
        paused = true;
        emit ContractPaused(msg.sender, block.timestamp);
    }

    /// @notice Unpause contract
    function unpause() external onlyPauser {
        paused = false;
        emit ContractUnpaused(msg.sender, block.timestamp);
    }

    /// @notice Set new pauser address
    function setPauser(address newPauser) external onlyOwner {
        require(newPauser != address(0), "Invalid pauser address");
        address oldPauser = pauser;
        pauser = newPauser;
        emit PauserChanged(oldPauser, newPauser);
    }

    /// @notice Register user with encrypted credentials using input proof verification
    /// @dev Demonstrates ZKPoK (Zero-Knowledge Proof of Knowledge) verification
    /// @param encryptedUserId Encrypted input for user ID
    /// @param encryptedCreditScore Encrypted input for credit score
    /// @param hasLicense Encrypted input for license verification
    /// @param initialBalance Encrypted input for wallet balance
    function registerUser(
        einput encryptedUserId,
        einput encryptedCreditScore,
        einput hasLicense,
        einput initialBalance,
        bytes calldata inputProof
    ) external whenNotPaused {
        if (userProfiles[msg.sender].isRegistered) revert("User already registered");

        // Input proof verification - ZKPoK verification for encrypted inputs
        euint32 encUserId = FHE.asEuint32(encryptedUserId, inputProof);
        euint32 encCreditScore = FHE.asEuint32(encryptedCreditScore, inputProof);
        ebool encHasLicense = FHE.asEbool(hasLicense, inputProof);
        euint64 encBalance = FHE.asEuint64(initialBalance, inputProof);

        // Validate credit score range (300-1000) using encrypted comparison
        euint32 minScore = FHE.asEuint32(300);
        euint32 maxScore = FHE.asEuint32(1000);
        ebool validCreditScore = FHE.and(
            FHE.gte(encCreditScore, minScore),
            FHE.lte(encCreditScore, maxScore)
        );

        // Fail-closed: if credit score is invalid, revert (after decryption in production)
        // For now, we store and can verify later via Gateway

        userProfiles[msg.sender] = UserProfile({
            encryptedUserId: encUserId,
            encryptedCreditScore: encCreditScore,
            hasValidLicense: encHasLicense,
            encryptedWalletBalance: encBalance,
            isRegistered: true,
            totalReservations: 0,
            lastReservation: 0
        });

        encryptedUserIds[msg.sender] = encUserId;

        // Set access permissions for all encrypted values
        FHE.allowThis(encUserId);
        FHE.allowThis(encCreditScore);
        FHE.allowThis(encHasLicense);
        FHE.allowThis(encBalance);
        FHE.allow(encUserId, msg.sender);
        FHE.allow(encCreditScore, msg.sender);
        FHE.allow(encHasLicense, msg.sender);
        FHE.allow(encBalance, msg.sender);

        emit UserRegistered(msg.sender, block.timestamp);
    }

    /// @notice Add parking spot with encrypted metadata
    /// @dev Uses multiple encryption types for comprehensive data protection
    function addParkingSpot(
        uint32 _price,
        string memory _location,
        uint32 _capacity
    ) external onlyOwner whenNotPaused {
        euint32 encPrice = FHE.asEuint32(_price);
        euint8 encStatus = FHE.asEuint8(0); // 0 = 可用
        euint32 encReservedBy = FHE.asEuint32(0); // 0 = 无人预订
        euint64 encReservationEnd = FHE.asEuint64(0); // 0 = 无预订
        euint32 encCapacity = FHE.asEuint32(_capacity);

        parkingSpots[totalSpots] = ParkingSpot({
            encryptedPrice: encPrice,
            encryptedStatus: encStatus,
            isActive: true,
            encryptedReservedBy: encReservedBy,
            encryptedReservationEnd: encReservationEnd,
            location: _location,
            encryptedCapacity: encCapacity
        });

        // Set access permissions
        FHE.allowThis(encPrice);
        FHE.allowThis(encStatus);
        FHE.allowThis(encReservedBy);
        FHE.allowThis(encReservationEnd);
        FHE.allowThis(encCapacity);

        emit SpotAdded(totalSpots, _location, block.timestamp);
        totalSpots++;
    }

    /// @notice Check spot availability using encrypted comparison
    /// @dev Demonstrates complex FHE logic with multiple conditions
    function checkSpotAvailability(uint32 spotId)
        external
        view
        validSpot(spotId)
        returns (ebool)
    {
        ParkingSpot storage spot = parkingSpots[spotId];

        // Check if status is available (0)
        euint8 availableStatus = FHE.asEuint8(0);
        ebool isStatusAvailable = FHE.eq(spot.encryptedStatus, availableStatus);

        // Check if reservation has ended (current time > reservation end)
        euint64 currentTime = FHE.asEuint64(uint64(block.timestamp));
        ebool isTimeExpired = FHE.gt(currentTime, spot.encryptedReservationEnd);

        // Spot is available if status is available OR time has expired
        ebool isAvailable = FHE.or(isStatusAvailable, isTimeExpired);

        return isAvailable;
    }

    /// @notice Request decryption of spot availability via Gateway
    /// @dev Demonstrates Gateway integration for async decryption
    function requestSpotAvailabilityDecryption(uint32 spotId)
        external
        validSpot(spotId)
        whenNotPaused
        returns (uint256 requestId)
    {
        ebool availability = this.checkSpotAvailability(spotId);

        // Request decryption via Gateway
        uint256[] memory cts = new uint256[](1);
        cts[0] = Gateway.toUint256(availability);

        requestId = Gateway.requestDecryption(
            cts,
            this.callbackSpotAvailability.selector,
            0,
            block.timestamp + 100,
            false
        );

        gatewayRequests[requestId] = GatewayRequest({
            requester: msg.sender,
            spotId: spotId,
            requestType: RequestType.AVAILABILITY_CHECK,
            fulfilled: false
        });

        emit GatewayRequestInitiated(requestId, msg.sender, RequestType.AVAILABILITY_CHECK);
    }

    /// @notice Gateway callback for spot availability
    /// @dev Called by Gateway after decryption
    function callbackSpotAvailability(
        uint256 requestId,
        bool decryptedAvailability
    ) public onlyGateway {
        GatewayRequest storage request = gatewayRequests[requestId];
        request.fulfilled = true;

        emit GatewayRequestFulfilled(requestId, decryptedAvailability);
    }

    // 预订停车位
    function reserveSpot(uint32 spotId, uint256 duration, uint16 paymentAmount) external onlyRegistered validSpot(spotId) {
        require(duration > 0 && duration <= 86400, "Invalid duration"); // 最多24小时
        require(paymentAmount > 0, "Payment required");

        ParkingSpot storage spot = parkingSpots[spotId];

        // 检查停车位是否可用
        euint8 availableStatus = FHE.asEuint8(0);
        ebool isAvailable = FHE.eq(spot.encryptedStatus, availableStatus);

        // 在实际应用中，这里需要async解密来验证
        // 为简化演示，假设检查通过

        uint256 startTime = block.timestamp;
        uint256 endTime = startTime + duration;

        // 加密支付金额和状态
        euint16 encPaidAmount = FHE.asEuint16(paymentAmount);
        euint8 encReservationStatus = FHE.asEuint8(0); // 0 = 进行中
        euint8 encSpotStatusReserved = FHE.asEuint8(1); // 1 = 已预订

        // 创建预订记录
        reservations[reservationCounter] = Reservation({
            spotId: spotId,
            encryptedUserId: userProfiles[msg.sender].encryptedUserId,
            encryptedPaidAmount: encPaidAmount,
            startTime: startTime,
            endTime: endTime,
            encryptedStatus: encReservationStatus,
            isActive: true
        });

        // 更新停车位状态
        spot.encryptedStatus = encSpotStatusReserved;
        spot.encryptedReservedBy = userProfiles[msg.sender].encryptedUserId;
        spot.reservationEnd = endTime;

        // 更新用户信息
        userProfiles[msg.sender].totalReservations++;
        userProfiles[msg.sender].lastReservation = startTime;
        userReservations[msg.sender].push(reservationCounter);

        // 设置访问权限
        FHE.allowThis(encPaidAmount);
        FHE.allowThis(encReservationStatus);
        FHE.allow(encPaidAmount, msg.sender);
        FHE.allow(encReservationStatus, msg.sender);

        emit ReservationCreated(reservationCounter, spotId, msg.sender);
        reservationCounter++;
    }

    // 完成预订
    function completeReservation(uint256 reservationId) external {
        require(reservationId < reservationCounter, "Invalid reservation ID");

        Reservation storage reservation = reservations[reservationId];
        require(reservation.isActive, "Reservation not active");
        require(block.timestamp >= reservation.endTime, "Reservation not ended yet");

        // 更新预订状态为已完成
        euint8 completedStatus = FHE.asEuint8(1); // 1 = 已完成
        reservation.encryptedStatus = completedStatus;

        // 释放停车位
        ParkingSpot storage spot = parkingSpots[reservation.spotId];
        euint8 availableStatus = FHE.asEuint8(0); // 0 = 可用
        euint32 noReserver = FHE.asEuint32(0); // 0 = 无人预订

        spot.encryptedStatus = availableStatus;
        spot.encryptedReservedBy = noReserver;
        spot.reservationEnd = 0;

        // 设置访问权限
        FHE.allowThis(completedStatus);
        FHE.allowThis(availableStatus);
        FHE.allowThis(noReserver);

        emit ReservationCompleted(reservationId, reservation.spotId);
    }

    // 取消预订
    function cancelReservation(uint256 reservationId) external {
        require(reservationId < reservationCounter, "Invalid reservation ID");

        Reservation storage reservation = reservations[reservationId];
        require(reservation.isActive, "Reservation not active");
        require(block.timestamp < reservation.startTime + 1800, "Cannot cancel after 30 minutes"); // 30分钟内可取消

        // 验证是否为预订者（需要解密验证，这里简化处理）
        // 在实际应用中需要使用FHE比较

        // 更新预订状态为已取消
        euint8 cancelledStatus = FHE.asEuint8(2); // 2 = 已取消
        reservation.encryptedStatus = cancelledStatus;
        reservation.isActive = false;

        // 释放停车位
        ParkingSpot storage spot = parkingSpots[reservation.spotId];
        euint8 availableStatus = FHE.asEuint8(0); // 0 = 可用
        euint32 noReserver = FHE.asEuint32(0); // 0 = 无人预订

        spot.encryptedStatus = availableStatus;
        spot.encryptedReservedBy = noReserver;
        spot.reservationEnd = 0;

        // 设置访问权限
        FHE.allowThis(cancelledStatus);
        FHE.allowThis(availableStatus);
        FHE.allowThis(noReserver);

        emit ReservationCancelled(reservationId, reservation.spotId);
    }

    // 更新停车位价格（仅管理员）
    function updateSpotPrice(uint32 spotId, uint16 newPrice) external onlyOwner validSpot(spotId) {
        euint16 encNewPrice = FHE.asEuint16(newPrice);

        parkingSpots[spotId].encryptedPrice = encNewPrice;

        FHE.allowThis(encNewPrice);

        emit PriceUpdated(spotId);
    }

    // 设置停车位维护状态（仅管理员）
    function setSpotMaintenance(uint32 spotId, bool inMaintenance) external onlyOwner validSpot(spotId) {
        euint8 newStatus = FHE.asEuint8(inMaintenance ? 2 : 0); // 2 = 维护中, 0 = 可用

        parkingSpots[spotId].encryptedStatus = newStatus;

        FHE.allowThis(newStatus);

        emit SpotStatusUpdated(spotId);
    }

    // 获取用户预订历史
    function getUserReservations(address user) external view returns (uint256[] memory) {
        return userReservations[user];
    }

    // 获取停车位信息（公开信息）
    function getSpotInfo(uint32 spotId) external view validSpot(spotId) returns (
        string memory location,
        bool isActive,
        uint256 reservationEnd
    ) {
        ParkingSpot storage spot = parkingSpots[spotId];
        return (spot.location, spot.isActive, spot.reservationEnd);
    }

    // 获取预订信息（公开信息）
    function getReservationInfo(uint256 reservationId) external view returns (
        uint32 spotId,
        uint256 startTime,
        uint256 endTime,
        bool isActive
    ) {
        require(reservationId < reservationCounter, "Invalid reservation ID");

        Reservation storage reservation = reservations[reservationId];
        return (
            reservation.spotId,
            reservation.startTime,
            reservation.endTime,
            reservation.isActive
        );
    }

    // 获取总体统计信息
    function getStatistics() external view returns (
        uint32 totalParkingSpots,
        uint256 totalReservations,
        uint256 currentTime
    ) {
        return (totalSpots, reservationCounter, block.timestamp);
    }

    // 验证用户身份（使用加密比较）
    function verifyUserIdentity(address user, uint32 providedUserId) external returns (ebool) {
        require(userProfiles[user].isRegistered, "User not registered");

        euint32 encProvidedId = FHE.asEuint32(providedUserId);
        euint32 storedId = userProfiles[user].encryptedUserId;

        return FHE.eq(encProvidedId, storedId);
    }

    // 紧急停车位释放（仅管理员）
    function emergencyReleaseSpot(uint32 spotId) external onlyOwner validSpot(spotId) {
        ParkingSpot storage spot = parkingSpots[spotId];

        euint8 availableStatus = FHE.asEuint8(0); // 0 = 可用
        euint32 noReserver = FHE.asEuint32(0); // 0 = 无人预订

        spot.encryptedStatus = availableStatus;
        spot.encryptedReservedBy = noReserver;
        spot.reservationEnd = 0;

        FHE.allowThis(availableStatus);
        FHE.allowThis(noReserver);

        emit SpotStatusUpdated(spotId);
    }
}